{"version":3,"sources":["models/CardModel.js","components/Card/Card.js","components/Button/Button.js","components/PlayerScore/PlayerScore.js","components/Instructions/Instructions.js","components/GameStart/GameStart.js","components/GameOver/GameOverSubtitle/GameOverSubTitle.js","components/GameOver/GameOver.js","components/Game/Game.js","App.js","reportWebVitals.js","index.js"],"names":["CardModel","id","groupId","thumbnail","this","selected","matched","Card","props","className","onClick","index","turn","Button","title","PlayerScore","name","score","Instructions","show","GameStart","setShowGameStart","showGameStart","setShowInstructions","showInstructions","GameOverSubtitle","isTie","winningPlayerName","GameOver","resetGame","debugLog","logMsg","Game","deck","generateDeck","firstCard","secondCard","playerScores","players","useState","playerTurn","setPlayerTurn","buildCardList","cardList","setCardList","showGameOver","setShowGameOver","winningPlayer","setWinningPlayer","playerOneScore","setPlayerOneScore","playerTwoScore","setPlayerTwoScore","includes","numberOfPairs","deckArr","sequence","i","push","array","temporaryValue","randomIndex","currentIndex","length","Math","floor","random","shuffle","data","map","c","handleSelectCard","setTimeout","cardOne","cardTwo","playerOneScr","playerTwoScr","updateScores","deselectCards","filter","card","indexOf","max","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.441585c3.chunk.js","sourcesContent":["export default class CardModel {\r\n  constructor(id, groupId, thumbnail) {\r\n    this.id = id;\r\n    this.groupId = groupId;\r\n    this.selected = false;\r\n    this.matched = false;\r\n    this.thumbnail = thumbnail;\r\n  };\r\n}","import \"./Card.css\";\r\n\r\nfunction Card(props) {\r\n  return (\r\n    <div className=\"scene\" onClick={() => {props.onClick(props.index)}}>\r\n      <div className={`card ${props.selected || props.matched ? 'is-flipped' : ''} ${props.matched ? props.turn ? 'fly-right' : 'fly-left' : ''}`}>\r\n        <div className=\"card__face card__face--front\"></div>\r\n        <div className={`card__face card__face--back card-${props.groupId}`}></div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Card;\r\n","import './Button.css'\r\n\r\nfunction Button(props) {\r\n  return <button onClick={props.onClick}>{props.title}</button>\r\n}\r\n\r\nexport default Button;","import './PlayerScore.css';\r\n\r\nexport default function PlayerScore(props) {\r\n\r\n  return (\r\n    <div id={props.id} className={`player ${props.turn ? 'active' : ''}`}>\r\n      <h4 className='playerName'>{props.name}</h4>\r\n      <p className='score'>Score: {props.score}</p>\r\n    </div>\r\n  );\r\n}","import './Instructions.css'\r\n\r\nexport default function Instructions(props) {\r\n  return (props.show \r\n    ? <p id={props.id} className='instructions'>The rules of the game our simple. Its a 2 player game. Player 1 goes first and selects two cards. If the cards match then they are removed from the board, and the player gets a point and another turn. The player continues to make selections until they don't make a matching selection. If two cards don't match they will be flipped back over and then player 2 gets to select cards with the same rules. This back and forth continues until all matched have been found between both players. Good luck!</p> \r\n    : '');\r\n}","import './GameStart.css'\r\nimport Button from '../Button/Button';\r\nimport Instructions from '../Instructions/Instructions';\r\n\r\nexport default function GameStart(props) {\r\n  return (\r\n    <div className={`startMenu`}>\r\n      <div className='gameStartContent'>\r\n        <h1 className='gameTitle'>Welcome to Card Matcher</h1>\r\n        <div className='buttonMenu'>\r\n          <Button title=\"Start Game\" onClick={() => {props.setShowGameStart(!props.showGameStart)}}/>\r\n          <Button title=\"Instructions\" onClick={() => {props.setShowInstructions(!props.showInstructions)}}/>\r\n        </div>\r\n        <Instructions show={props.showInstructions}/>\r\n      </div>\r\n    </div> \r\n  );\r\n}","export default function GameOverSubtitle(props) {\r\n  return props.isTie \r\n  ? <p>{props.winningPlayerName} wins!</p>\r\n  : <p>Tie Game!</p>\r\n}","import './GameOver.css'\r\nimport GameOverSubTitle from './GameOverSubtitle/GameOverSubTitle';\r\nimport Button from '../Button/Button';\r\n\r\nexport default function GameOver(props) {\r\n  return (\r\n    <div className='gameOver'>\r\n      <div className='gameOverContent'>\r\n        <h1>Game Over!</h1>\r\n        <GameOverSubTitle isTie={props.isTie} winningPlayerName={props.winningPlayerName}/>\r\n        <Button title=\"New Game\" onClick={() => {props.resetGame()}}/>\r\n      </div>\r\n    </div>\r\n  )\r\n}","import './Game.css';\nimport CardModel from '../../models/CardModel';\nimport Card from '../Card/Card';\nimport Button from '../Button/Button';\nimport PlayerScore from '../PlayerScore/PlayerScore';\nimport GameStart from '../GameStart/GameStart';\nimport GameOver from '../GameOver/GameOver';\nimport { useState } from 'react';\n\nlet debuggingOn = false;\n\nfunction debugLog(logMsg) {\n  if (debuggingOn) console.log(logMsg);\n}\n\nexport default function Game() {\n\n  let deck = generateDeck(10);\n  let firstCard = null;\n  let secondCard = null;\n  let playerScores = [0, 0]\n  let players = ['Player One', 'Player Two'];\n  let [playerTurn, setPlayerTurn] = useState(0);\n  const [cardList, setCardList] = useState(buildCardList(deck));\n  const [showGameOver, setShowGameOver] = useState(false);\n  const [showGameStart, setShowGameStart] = useState(true);\n  const [showInstructions, setShowInstructions] = useState(false);\n  const [winningPlayer, setWinningPlayer] = useState(0);\n  const [playerOneScore, setPlayerOneScore] = useState(0)\n  const [playerTwoScore, setPlayerTwoScore] = useState(0)\n\n  return (\n      <div className='gameBorder'>\n        { \n          showGameStart\n          ? <GameStart \n              setShowGameStart={setShowGameStart}\n              showGameStart={showGameStart}\n              setShowInstructions={setShowInstructions}\n              showInstructions={showInstructions}/>\n          : null\n        }\n\n        { \n          showGameOver\n          ? <GameOver\n              isTie={[0, 1].includes(winningPlayer)}\n              winningPlayerName={players[winningPlayer]}\n              resetGame={resetGame}/>\n          : null\n        }\n\n        <div className='gameBoard'>\n          {cardList}\n        </div>\n\n        <div className='leaderBoard'>\n          <PlayerScore\n            id='playerOne' \n            name={players[0]}\n            score={playerOneScore}\n            turn={!playerTurn}\n          />\n          <PlayerScore\n            id='playerTwo' \n            name={players[1]}\n            score={playerTwoScore}\n            turn={playerTurn}\n          />\n        </div>\n\n        <div className='gameMenu buttonMenu'>\n          <Button title=\"Main Menu\" onClick={() => {setShowGameStart(!showGameStart)}}/>\n          <Button title=\"Restart Game\" onClick={() => {resetGame()}}/>\n        </div>\n      </div>\n  );\n\n  function generateDeck(numberOfPairs) {\n    let deckArr = [];\n    let sequence = 1;\n    for (let i = 1; i <= numberOfPairs; i++) {\n      deckArr.push(new CardModel(sequence++, i, \"https://picsum.photos/200/300\"))\n      deckArr.push(new CardModel(sequence++, i, \"https://picsum.photos/200/300\"))\n    }\n    shuffle(deckArr)\n    return deckArr\n  }\n\n  function buildCardList(data) {\n    return data.map(c => {\n      return (\n        <Card key={c.id}\n              index={c.index}\n              groupId={c.groupId}\n              selected={c.selected}\n              matched={c.matched}\n              turn={playerTurn}\n              onClick={handleSelectCard}\n        />\n      )\n    });\n  }\n\n  function shuffle(array) {\n    var currentIndex = array.length, temporaryValue, randomIndex;\n\n    // While there remain elements to shuffle...\n    while (0 !== currentIndex) {\n\n      // Pick a remaining element...\n      randomIndex = Math.floor(Math.random() * currentIndex);\n      currentIndex -= 1;\n\n      // And swap it with the current element.\n      temporaryValue = array[currentIndex];\n      array[currentIndex] = array[randomIndex];\n\n      // This line is very important for the function of the games logic.\n      // Sets the index of the card in the deck, after being shuffled.\n      // This index is used for reference in the selection handling.\n      array[currentIndex].index = currentIndex;\n      array[randomIndex] = temporaryValue;\n    }\n\n    return array;\n  }\n\n  function handleSelectCard(index) {\n    // If both cards are already selected, don't register the selection.\n    // Don't do anything if the card selected is already selected, or already matched.\n    if ((firstCard && secondCard) ||\n        (firstCard && firstCard.index === index) ||\n        deck[index].selected || deck[index].matched ) return;\n\n    deck[index].selected = true;\n\n    // If its the first card selected, set a reference to the card in the deck.\n    // Otherwise set a reference to the second card selected.\n    if (!firstCard) {\n      firstCard = deck[index]\n    } else {\n      secondCard = deck[index]\n    }\n\n    setCardList(buildCardList(deck));\n\n    // Wait for the second card to show itself, before attempting to hide (deselect) it.\n    let waitTime = firstCard && secondCard ? 1.5 * 1000 : 0;\n    setTimeout(() => {\n      if (firstCard && secondCard) {\n        // Check if selected cards are a match\n        checkForMatch(firstCard, secondCard);\n\n        // Always deselect the cards. If they are a match\n        // they will slide away because the 'matched' property on the card\n        // is a fall back value that also shows the card.\n        deselectCards(firstCard, secondCard)\n      }\n      \n      // Render cards\n      setCardList(buildCardList(deck));\n  \n      checkForEndGame();\n    }, waitTime)\n  }\n\n  function checkForMatch(cardOne, cardTwo) {\n    if (cardOne.groupId === cardTwo.groupId && cardOne.id !== cardTwo.id) {\n      // Animate cards sliding off board.\n      updateScores(cardOne, cardTwo)\n    } else {\n      switchTurns();\n    }\n  }\n\n  function updateScores(cardOne, cardTwo) {\n    debugLog('Updating score...')\n\n    cardOne.matched = cardTwo.matched = true;\n\n    // PlayerTurn is 0 or 1, so using it as the index we can select\n    // what score in a 2 object array we want to update.\n    playerScores[playerTurn] += 1;\n\n    // Had to seperate out the playerScores into decoupled states,\n    // and render state using setPlayerOne and setPlayerTwo\n    // because I was having state manipulation issues I couldn't solve.\n    // For example when retrieving the state of something I just updated,\n    // it wouldn't be updated yet, and would still be in queue waiting to be updated.\n\n    let [playerOneScr, playerTwoScr] = playerScores;\n\n    setPlayerOneScore(playerOneScr);\n    setPlayerTwoScore(playerTwoScr);\n  }\n\n  function deselectCards(cardOne, cardTwo) {\n    // Render logic\n    cardOne.selected = false;\n    cardTwo.selected = false;\n\n    // Game logic\n    firstCard = null;\n    secondCard = null;\n  }\n\n  function switchTurns() {\n    debugLog('Switching player turns...');\n    // Swap turns here.\n    playerTurn = playerTurn ? 0 : 1;\n    setPlayerTurn(playerTurn);\n  }\n\n  function checkForEndGame() {\n    let unmatchedCardCount = deck.filter((card) => {\n      return card.matched === false\n    }).length\n\n    if (unmatchedCardCount === 0) {\n      \n      debugLog('Game over...')\n      if (playerScores[0] !== playerScores[1]) {\n        // Get the indexOf the greater value\n        setWinningPlayer(playerScores.indexOf(Math.max(playerScores[0], playerScores[1])));\n      } else {\n        // In the event of a tie\n        setWinningPlayer(-1);\n      }\n      \n      setShowGameOver(true);\n    }\n  }\n\n  function resetGame() {\n    debugLog('Resetting game...')\n    deck = generateDeck(10);\n    setTimeout(\n      setCardList(buildCardList(deck)), 200\n    )\n    playerScores = [0, 0];\n    firstCard = null;\n    secondCard = null;\n    setPlayerOneScore(0);\n    setPlayerTwoScore(0);\n    setPlayerTurn(0)\n    setShowGameOver(false);\n  }\n}","import './App.css';\nimport Game from './components/Game/Game';\n\nexport default function App() {\n  return (\n      <Game />\n  )\n}\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}