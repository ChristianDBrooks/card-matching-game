{"version":3,"sources":["models/CardModel.js","components/Card/Card.js","components/Button/Button.js","components/PlayerScore/PlayerScore.js","components/Instructions/Instructions.js","components/GameStart/GameStart.js","components/GameOver/GameOverSubtitle/GameOverSubTitle.js","components/GameOver/GameOver.js","components/Game/Game.js","App.js","reportWebVitals.js","index.js"],"names":["CardModel","id","groupId","this","index","selected","flipped","matched","Card","props","className","onClick","turn","Button","style","backgroundColor","color","title","PlayerScore","name","score","Instructions","show","GameStart","changeButton","handleStartGame","showGameStart","setShowInstructions","showInstructions","revealCards","setRevealCards","GameOverSubtitle","isTie","winningPlayerName","GameOver","resetGame","debugLog","logMsg","Game","deck","generateDeck","firstCard","secondCard","playerScores","players","useState","playerTurn","setPlayerTurn","buildCardList","cardList","setCardList","showGameOver","setShowGameOver","setShowGameStart","setChangeButton","winningPlayer","setWinningPlayer","playerOneScore","setPlayerOneScore","playerTwoScore","setPlayerTwoScore","showMenu","revealAllCards","includes","numberOfPairs","deckArr","sequence","i","push","array","temporaryValue","randomIndex","currentIndex","length","Math","floor","random","shuffle","data","map","c","handleSelectCard","forEach","card","setTimeout","flipCard","cardOne","cardTwo","playerOneScr","playerTwoScr","updateScores","deselectCards","filter","indexOf","max","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.57e74c38.chunk.js","sourcesContent":["export default class CardModel {\r\n  constructor(id, groupId) {\r\n    this.id = id;\r\n    this.index = null;\r\n    this.groupId = groupId;\r\n    this.selected = false;\r\n    this.flipped = false;\r\n    this.matched = false;\r\n  };\r\n}","import \"./Card.css\";\r\n\r\nfunction Card(props) {\r\n  return (\r\n    <div className=\"scene\" onClick={() => {props.onClick(props.index)}}>\r\n      <div className={`card ${props.selected || props.flipped || props.matched ? 'is-flipped' : ''} ${props.matched ? props.turn ? 'fly-right' : 'fly-left' : ''}`}>\r\n        <div className=\"card__face card__face--front\"></div>\r\n        <div className={`card__face card__face--back card-${props.groupId}`}></div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Card;\r\n","import './Button.css'\r\n\r\nfunction Button(props) {\r\n  return <button style={{backgroundColor: props.color}} onClick={props.onClick}>{props.title}</button>\r\n}\r\n\r\nexport default Button;","import './PlayerScore.css';\r\n\r\nexport default function PlayerScore(props) {\r\n\r\n  return (\r\n    <div id={props.id} className={`player ${props.turn ? 'active' : ''}`}>\r\n      <h4 className='playerName'>{props.name}</h4>\r\n      <p className='score'>Score: {props.score}</p>\r\n    </div>\r\n  );\r\n}","import './Instructions.css'\r\n\r\nexport default function Instructions(props) {\r\n  return (props.show \r\n    ? <p id={props.id} className='instructions'>The rules of the game our simple. Its a 2 player game. Player 1 goes first and selects two cards. If the cards match then they are removed from the board, and the player gets a point and another turn. The player continues to make selections until they don't make a matching selection. If two cards don't match they will be flipped back over and then player 2 gets to select cards with the same rules. This back and forth continues until all matched have been found between both players. Good luck!</p> \r\n    : '');\r\n}","import './GameStart.css'\r\nimport Button from '../Button/Button';\r\nimport Instructions from '../Instructions/Instructions';\r\n\r\nexport default function GameStart(props) {\r\n  return (\r\n    <div className={`startMenu`}>\r\n      <div className='gameStartContent'>\r\n        <h1 className='gameTitle'>Welcome to Card Matcher</h1>\r\n        <div className='buttonMenu'>\r\n          <Button title={`${props.changeButton ? 'Continue' : 'Start'} Game`} onClick={() => {props.handleStartGame(!props.showGameStart)}}/>\r\n          <Button title=\"Instructions\" onClick={() => props.setShowInstructions(!props.showInstructions)}/>\r\n          <Button title=\"Show Cards at Beginning\" color={props.revealCards ? 'green' : 'white'} onClick={() => props.setRevealCards(!props.revealCards)}/>\r\n        </div>\r\n        <Instructions show={props.showInstructions}/>\r\n      </div>\r\n    </div> \r\n  );\r\n}","export default function GameOverSubtitle(props) {\r\n  return props.isTie \r\n  ? <p>{props.winningPlayerName} wins!</p>\r\n  : <p>Tie Game!</p>\r\n}","import './GameOver.css'\r\nimport GameOverSubTitle from './GameOverSubtitle/GameOverSubTitle';\r\nimport Button from '../Button/Button';\r\n\r\nexport default function GameOver(props) {\r\n  return (\r\n    <div className='gameOver'>\r\n      <div className='gameOverContent'>\r\n        <h1>Game Over!</h1>\r\n        <GameOverSubTitle isTie={props.isTie} winningPlayerName={props.winningPlayerName}/>\r\n        <Button title=\"New Game\" onClick={() => {props.resetGame()}}/>\r\n      </div>\r\n    </div>\r\n  )\r\n}","import './Game.css';\nimport CardModel from '../../models/CardModel';\nimport Card from '../Card/Card';\nimport Button from '../Button/Button';\nimport PlayerScore from '../PlayerScore/PlayerScore';\nimport GameStart from '../GameStart/GameStart';\nimport GameOver from '../GameOver/GameOver';\nimport { useState } from 'react';\n\nlet debuggingOn = false;\n\nfunction debugLog(logMsg) {\n  if (debuggingOn) console.log(logMsg);\n}\n\nexport default function Game() {\n\n  let deck = generateDeck(10);\n  let firstCard = null;\n  let secondCard = null;\n  let playerScores = [0, 0]\n  let players = ['Player One', 'Player Two'];\n  let [playerTurn, setPlayerTurn] = useState(0);\n  const [revealCards, setRevealCards] = useState(true);\n  const [cardList, setCardList] = useState(buildCardList(deck));\n  const [showGameOver, setShowGameOver] = useState(false);\n  const [showGameStart, setShowGameStart] = useState(true);\n  const [changeButton, setChangeButton] = useState(false);\n  const [showInstructions, setShowInstructions] = useState(false);\n  const [winningPlayer, setWinningPlayer] = useState(0);\n  const [playerOneScore, setPlayerOneScore] = useState(0)\n  const [playerTwoScore, setPlayerTwoScore] = useState(0)\n\n  return (\n      <div className='gameBorder'>\n        { \n          showGameStart\n          ? <GameStart \n              changeButton={changeButton}\n              handleStartGame={handleStartGame}\n              showGameStart={showGameStart}\n              setShowInstructions={setShowInstructions}\n              showInstructions={showInstructions}\n              setRevealCards={setRevealCards}\n              revealCards={revealCards}/>\n          : null\n        }\n\n        { \n          showGameOver\n          ? <GameOver\n              isTie={[0, 1].includes(winningPlayer)}\n              winningPlayerName={players[winningPlayer]}\n              resetGame={resetGame}/>\n          : null\n        }\n\n        <div className='gameBoard'>\n          {cardList}\n        </div>\n\n        <div className='leaderBoard'>\n          <PlayerScore\n            id='playerOne' \n            name={players[0]}\n            score={playerOneScore}\n            turn={!playerTurn}\n          />\n          <PlayerScore\n            id='playerTwo' \n            name={players[1]}\n            score={playerTwoScore}\n            turn={playerTurn}\n          />\n        </div>\n\n        <div className='gameMenu buttonMenu'>\n          <Button title=\"Main Menu\" onClick={() => {setShowGameStart(!showGameStart)}}/>\n          <Button title=\"Restart Game\" onClick={() => {resetGame()}}/>\n        </div>\n      </div>\n  );\n\n  function generateDeck(numberOfPairs) {\n    let deckArr = [];\n    let sequence = 1;\n    for (let i = 1; i <= numberOfPairs; i++) {\n      deckArr.push(new CardModel(sequence++, i, \"https://picsum.photos/200/300\"))\n      deckArr.push(new CardModel(sequence++, i, \"https://picsum.photos/200/300\"))\n    }\n    shuffle(deckArr)\n    return deckArr\n  }\n\n  function buildCardList(data) {\n    return data.map(c => {\n      return (\n        <Card key={c.id}\n              index={c.index}\n              groupId={c.groupId}\n              selected={c.selected}\n              flipped={c.flipped}\n              matched={c.matched}\n              turn={playerTurn}\n              onClick={handleSelectCard}\n        />\n      )\n    });\n  }\n\n  function shuffle(array) {\n    var currentIndex = array.length, temporaryValue, randomIndex;\n\n    // While there remain elements to shuffle...\n    while (0 !== currentIndex) {\n\n      // Pick a remaining element...\n      randomIndex = Math.floor(Math.random() * currentIndex);\n      currentIndex -= 1;\n\n      // And swap it with the current element.\n      temporaryValue = array[currentIndex];\n      array[currentIndex] = array[randomIndex];\n\n      // This line is very important for the function of the games logic.\n      // Sets the index of the card in the deck, after being shuffled.\n      // This index is used for reference in the selection handling.\n      array[currentIndex].index = currentIndex;\n      array[randomIndex] = temporaryValue;\n    }\n\n    return array;\n  }\n\n  function handleStartGame(showMenu) {\n    if (!changeButton) setChangeButton(true);\n    setShowGameStart(showMenu);\n    if (!changeButton) revealAllCards();\n  }\n\n  function revealAllCards() {\n    // If reveal setting is turned on in main menu...\n    if (revealCards) {\n      deck.forEach((card, index) => {\n        // Instead of flipping them all over at once, snake through the deck\n        // and flip each card over one after the other, with a seperation for\n        // 100 ms between each flip.\n        setTimeout(() => {flipCard(card)}, (index + 1) * 100);\n      })\n    }\n  }\n\n  function flipCard(card) {\n    // Use a unique field called 'flipped' so that game\n    // logic doesn't get corrupted by using 'select'.\n    card.flipped = true;\n    // Once we render the deck changes, the cards will flip.\n    setCardList(buildCardList(deck))\n    // Reveal the card for a total of 2 seconds, then flip it back.\n    setTimeout(() => {\n      card.flipped = false;\n      setCardList(buildCardList(deck))\n    }, 2500);\n  }\n\n  function handleSelectCard(index) {\n    // If both cards are already selected, don't register the selection.\n    // Don't do anything if the card selected is already selected, or already matched.\n    if ((firstCard && secondCard) ||\n        (firstCard && firstCard.index === index) ||\n        deck[index].selected || deck[index].matched ) return;\n\n    deck[index].selected = true;\n\n    // If its the first card selected, set a reference to the card in the deck.\n    // Otherwise set a reference to the second card selected.\n    if (!firstCard) {\n      firstCard = deck[index]\n    } else {\n      secondCard = deck[index]\n    }\n\n    setCardList(buildCardList(deck));\n\n    // Wait for the second card to show itself, before attempting to hide (deselect) it.\n    let waitTime = firstCard && secondCard ? 1.5 * 1000 : 0;\n    setTimeout(() => {\n      if (firstCard && secondCard) {\n        // Check if selected cards are a match\n        checkForMatch(firstCard, secondCard);\n\n        // Always deselect the cards. If they are a match\n        // they will slide away because the 'matched' property on the card\n        // is a fall back value that also shows the card.\n        deselectCards(firstCard, secondCard)\n      }\n      \n      // Render cards\n      setCardList(buildCardList(deck));\n  \n      checkForEndGame();\n    }, waitTime)\n  }\n\n  function checkForMatch(cardOne, cardTwo) {\n    if (cardOne.groupId === cardTwo.groupId && cardOne.id !== cardTwo.id) {\n      // Animate cards sliding off board.\n      updateScores(cardOne, cardTwo)\n    } else {\n      switchTurns();\n    }\n  }\n\n  function updateScores(cardOne, cardTwo) {\n    debugLog('Updating score...')\n\n    cardOne.matched = cardTwo.matched = true;\n\n    // PlayerTurn is 0 or 1, so using it as the index we can select\n    // what score in a 2 object array we want to update.\n    playerScores[playerTurn] += 1;\n\n    // Had to seperate out the playerScores into decoupled states,\n    // and render state using setPlayerOne and setPlayerTwo\n    // because I was having state manipulation issues I couldn't solve.\n    // For example when retrieving the state of something I just updated,\n    // it wouldn't be updated yet, and would still be in queue waiting to be updated.\n\n    let [playerOneScr, playerTwoScr] = playerScores;\n\n    setPlayerOneScore(playerOneScr);\n    setPlayerTwoScore(playerTwoScr);\n  }\n\n  function deselectCards(cardOne, cardTwo) {\n    // Render logic\n    cardOne.selected = false;\n    cardTwo.selected = false;\n\n    // Game logic\n    firstCard = null;\n    secondCard = null;\n  }\n\n  function switchTurns() {\n    debugLog('Switching player turns...');\n    // Swap turns here.\n    playerTurn = playerTurn ? 0 : 1;\n    setPlayerTurn(playerTurn);\n  }\n\n  function checkForEndGame() {\n    let unmatchedCardCount = deck.filter((card) => {\n      return card.matched === false\n    }).length\n\n    if (unmatchedCardCount === 0) {\n      \n      debugLog('Game over...')\n      if (playerScores[0] !== playerScores[1]) {\n        // Get the indexOf the greater value\n        setWinningPlayer(playerScores.indexOf(Math.max(playerScores[0], playerScores[1])));\n      } else {\n        // In the event of a tie\n        setWinningPlayer(-1);\n      }\n      \n      setShowGameOver(true);\n    }\n  }\n\n  function resetGame() {\n    debugLog('Resetting game...')\n    deck = generateDeck(10);\n    setTimeout(\n      setCardList(buildCardList(deck)), 200\n    )\n    playerScores = [0, 0];\n    firstCard = null;\n    secondCard = null;\n    setPlayerOneScore(0);\n    setPlayerTwoScore(0);\n    setPlayerTurn(0)\n    setShowGameOver(false);\n    revealAllCards();\n  }\n}","import './App.css';\nimport Game from './components/Game/Game';\n\nexport default function App() {\n  return (\n      <Game />\n  )\n}\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}